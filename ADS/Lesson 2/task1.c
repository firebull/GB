/**
 * @copyright Nikita Bulaev 2019
 *
 * @file  task1.c
 * @brief Реализовать функцию перевода из 10 системы в двоичную используя рекурсию
 *
 */

#include <stdio.h>

/**
 * @brief Преобразование целого беззнакового 32-х битного числа в текстовое бинарное представление
 * @param num   беззнаковое 32-битное число
 * @param buff  Символьный буфер, куда записывается итоговое бинарное число
 * @param index Текущий индекс буфера
 */
void UintToBin(unsigned int num, char * buff, short * index) {

    if (num == 0 || *index == -1) {
        return;
    } else {
        buff[*index] = (num & 1) ? '1' : '0';
    }

    (*index)--;

    UintToBin(num >> 1, buff, index);
}

int main (int argc, const char * argv[]) {

    int n = 0;               /*!< Знаковое 32-битное число для преобразования */
    unsigned int number = 0; /*!< Беззнаковое 32-битное число для преобразования */
    char buff[33];           /*!< Символьный буфер, куда записывается итоговое бинарное число */
    short index = 31;        /*!< Текущий индекс буфера */

    // Для удобства заполним строку нулями.
    // Мне просто захотелось так, хотя можно и сразу строкой
    // инициализировать переменную.
    for (int i = 0; i < 31; ++i) {
        buff[i] = '0';
    }

    // Гарантированно терминирую строку, а то имеем шансы
    // выскочить за пределы выделенной памяти.
    buff[32] = '\0';

    printf("Enter an integer number: ");

    // Проверяю входное значение. Если это не целое число,
    // вываливаюсь с системной ошибкой.
    if (scanf("%d", &n) == 0) {
        printf("Invalid value, exitting.\n\n");
        return 1;  // Выходим с системной ошибкой
    }

    // Переведу signed int в unsigned без потери старшего бита
    // Делаю это безопасно, чтоб на любых платформах сработало
    number = *(unsigned int *)&n;

    // Если у нас отрицательное число, то я хочу
    // выводить прямой код числа, а не обратный.
    // Прямой код - это когда старший бит означает знак,
    // а остальная часть выводится как обычное положительное число.
    // При обратном коде делается инверсия кроме первого разряда, а
    // потом плюсуется единица к получившемуся инверсией числу.
    // По умолчанию, представление именно обратное.
    //
    // Соответственно тут я привожу к прямому коду, если
    // переданное число отрицательное
    if (n < 0) {
        number = (number - 1) ^ 0x7FFFFFFF;  // 0x7FFFFFFF - это 32-битное число с 0 в старшем бите
    }

    UintToBin(number, buff, &index);

    printf("Decimal number %d => b%s\n", n, buff);

    return 0;
}
